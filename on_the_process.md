# On The Process

The process of building a software project can be broken down into a few high level goals. These goals should be used as guiding stars for decision making. If the team is achieving these goals they are likely on the right path to making a successful software project. These goals are focused on the software creation part of a project. They don't necessarily encompass all the goals required to have a successful product. However, shirking these goals is likely going to produce unsightly software, and therefore an unsightly product.

## High Level Goals:

### 1. Regularly release new features

Progress on a project is important. It is a great benchmark to measure team progress against. When we set out to build a product we have in mind a set of features that it will contain. It is unlikely that we will be able to make all of these features at once. In order keep the pace of the project strong we should aim to deliver intermediate results. Delivering a feature will usually require collaboration among engineers. In this case, multiple engineers should collaborate to finish an incremental feature as quickly as possible. If a feature seems too hard to deliver in a short period of time, it is likely not small enough. Features that are too large can be broken down into smaller features. Not all features have to be directly user facing. A feature can be an improvement to the latency between the backend and frontend. However, a feature should be a noticeable modification in the function of the product. A refactor of the codebase is not to be considered a feature (however, this is still extremely important to do).

### 2. Be transparent about work

It should be easy to know exactly what each team member is working on at any given time. This doesn't necessarily mean that everyone has to understand that task, it just means that everyone should be able to know what it is. This is not meant to be a technique to micro-manage, but rather a technique to reach high throughput. In order to obtain the first goal of releasing often, it is necessary to coordinate work across multiple people. If it is clear who is working on what, it becomes clear which features are being worked on. Therefore we can easily determine which features are close to being done.

### 3. Effectively prioritize tasks

Every team member should be able to self prioritize tasks. As a team, we must agree on short term features / goals we are trying to accomplish. When deciding these goals we will break down the goal into a series of task necessary to complete the goal. Then at any moment, until the feature is complete, a team member should work on the next most important task that gets the team closer to the goal. In terms of individual prioritization each team member should have a general understanding of their area of expertise (frontend, backend, tooling, etc.) and work on important tasks related to that area. At some point each area will have its tasks complete for the current feature. In this case, the team members in that area should focus on scoping work for the upcoming features. Additionally, the can spend time working on increasing future velocity (more on this later). This implies another point, the team should have a small backlog of features to enable in the product. It should include the current feature being worked on and a few high priority features. It is important not to scope out work too far into the future because then it becomes difficult to adapt to new challenges that are uncovered.

### 4. Maintain linear feature complexity

Most projects follow a path of logarithmic growth in terms of feature complexity. A product starts with an initial explosion of features and as time goes on the amount of complexity in new features slows. A sign that this is happening in a project are when people say sentences like "That doesn't fit well with our architecture, it would require a large change." or "We will have to refactor the way we do X, which is complicated." While of course sometimes it IS hard to make large changes in architecture to enable a feature, users could not care less about this. Users want what users want and as a team it is our mission to enable these features. To accomplish this, we must always be forward thinking with our product. More about the principles of software design can be found online, but for the teams purpose, making a dynamic product is key. A good heuristic to apply when adding features is "If at some point we have to remove or completely change this feature, how difficult will this be." Ideally, the answer to that question should be "not difficult". This heuristic should be applied to every single technical or operational decision we make.

### 5. Consistently improve manual processes

Manual processes are expensive. It is hard to overstate how burdensome expensive manual processes are to a team. Any process that can be automated should be automated. A good example of this is testing. Imagine a project with absolutely no automated testing. Any time a team member wants to make a new change they have to check that every single previous feature still works. This would quickly add up on even the smallest project. To further show the cost of manual testing here is another example. For example, let's say manually testing a feature takes 5 seconds, while it takes 30 minutes to write an automated test. It would take running this test 360 times to make up the cost. This seems like a lot, but imagine a team of 5 people each working all day. They will likely need to run tests at least 10 times per day. This means it takes about a week to make up the difference. After that, every team member gets 1 minute per day back permanently. After the project has a few hundred tests it ends up saving hours per day of team member time. Manual process don't just include testing, they also include code formatting, system releases, and testing environments. All of these meta-aspects of building a project need to be improved over time. If manual processes are neglected, it will quickly reduce new feature development throughput.
